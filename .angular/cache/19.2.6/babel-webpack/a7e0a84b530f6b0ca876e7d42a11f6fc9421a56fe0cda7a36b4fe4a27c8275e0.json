{"ast":null,"code":"import { select, Store } from \"@ngrx/store\";\nimport * as fromRoot from \"../redux\";\nimport \"rxjs/add/observable/combineLatest\";\nimport { combineLatest } from \"rxjs\";\nimport { filter, map } from \"rxjs\";\nimport * as _ from \"lodash\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngrx/store\";\nexport let StoreTaskService = /*#__PURE__*/(() => {\n  class StoreTaskService {\n    constructor(store) {\n      this.store = store;\n    }\n    getOpenTask() {\n      return this._prepareOne(this.store.pipe(select(fromRoot.getTaskOpen)));\n    }\n    getTaskListByStatusId(statusId) {\n      return this._prepareAll(this.store.pipe(select(fromRoot.getTaskEntitiesByStatus(statusId))));\n    }\n    getTaskList() {\n      return this._prepareAll(this.store.pipe(select(fromRoot.getTaskEntities)));\n    }\n    _prepareAll(taskList$) {\n      const inviteList$ = this.store.pipe(select(fromRoot.getInviteEntities));\n      const statusList$ = this.store.pipe(select(fromRoot.getStatusEntities));\n      const tagList$ = this.store.pipe(select(fromRoot.getTagEntities));\n      return combineLatest(taskList$, inviteList$, statusList$, tagList$).pipe(filter(([taskList, inviteList, statusList, tagList]) => inviteList.length > 0 && statusList.length > 0), map(([taskList, inviteList, statusList, tagList]) => {\n        if (taskList && inviteList && statusList && tagList) {\n          taskList.forEach(task => {\n            if (task.responsibleId) {\n              task.responsible = _.find(inviteList, {\n                userId: task.responsibleId\n              });\n            }\n            if (task.statusId) {\n              task.status = _.find(statusList, {\n                id: task.statusId\n              });\n            }\n            task.tagList = [];\n            task.tags.forEach(tagId => {\n              const tag = _.find(tagList, {\n                id: tagId\n              });\n              if (tag) {\n                task.tagList.push(tag);\n              }\n            });\n          });\n        }\n        return taskList;\n      }));\n    }\n    _prepareOne(task$) {\n      const inviteList$ = this.store.pipe(select(fromRoot.getInviteEntities));\n      const statusList$ = this.store.pipe(select(fromRoot.getStatusEntities));\n      const tagList$ = this.store.pipe(select(fromRoot.getTagEntities));\n      return combineLatest(task$, inviteList$, statusList$, tagList$).pipe(filter(([task, inviteList, statusList, tagList]) => task && inviteList.length > 0 && statusList.length > 0), map(([task, inviteList, statusList, tagList]) => {\n        if (task.responsibleId) {\n          task.responsible = _.find(inviteList, {\n            userId: task.responsibleId\n          });\n        }\n        if (task.userIdArchive) {\n          task.userArchive = _.find(inviteList, {\n            userId: task.userIdArchive\n          });\n        }\n        if (task.userIdComplete) {\n          task.userComplete = _.find(inviteList, {\n            userId: task.userIdComplete\n          });\n        }\n        task.status = _.find(statusList, {\n          id: task.statusId\n        });\n        task.followersUsers = [];\n        task.followers.forEach(followerId => {\n          const follower = _.find(inviteList, {\n            userId: followerId\n          });\n          if (follower) {\n            task.followersUsers.push(follower.user);\n          }\n        });\n        task.tagList = [];\n        task.tags.forEach(tagId => {\n          const tag = _.find(tagList, {\n            id: tagId\n          });\n          if (tag) {\n            task.tagList.push(tag);\n          }\n        });\n        return task;\n      }));\n    }\n    static #_ = (() => this.ɵfac = function StoreTaskService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || StoreTaskService)(i0.ɵɵinject(i1.Store));\n    })();\n    static #_2 = (() => this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: StoreTaskService,\n      factory: StoreTaskService.ɵfac,\n      providedIn: \"root\"\n    }))();\n  }\n  return StoreTaskService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}