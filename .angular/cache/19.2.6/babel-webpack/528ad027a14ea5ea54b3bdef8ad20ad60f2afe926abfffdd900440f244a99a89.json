{"ast":null,"code":"\"use strict\";\n\nvar _this = this;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar INIT_ACTION = '@ngrx/store/init';\nvar UPDATE_ACTION = '@ngrx/store/update-reducers';\nvar detectDate = /(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})/;\n// correctly parse dates from local storage\nexports.dateReviver = function (key, value) {\n  if (typeof value === 'string' && detectDate.test(value)) {\n    return new Date(value);\n  }\n  return value;\n};\nvar dummyReviver = function (key, value) {\n  return value;\n};\nvar validateStateKeys = function (keys) {\n  return keys.map(function (key) {\n    var attr = key;\n    if (typeof key === 'object') {\n      attr = Object.keys(key)[0];\n    }\n    if (typeof attr !== 'string') {\n      throw new TypeError(\"localStorageSync Unknown Parameter Type: \" + (\"Expected type of string, got \" + typeof attr));\n    }\n    return key;\n  });\n};\nexports.rehydrateApplicationState = function (keys, storage, storageKeySerializer, restoreDates) {\n  return keys.reduce(function (acc, curr) {\n    var key = curr;\n    var reviver = restoreDates ? exports.dateReviver : dummyReviver;\n    var deserialize = undefined;\n    var decrypt = undefined;\n    if (typeof key === 'object') {\n      key = Object.keys(key)[0];\n      // use the custom reviver function\n      if (typeof curr[key] === 'function') {\n        reviver = curr[key];\n      } else {\n        // use custom reviver function if available\n        if (curr[key].reviver) {\n          reviver = curr[key].reviver;\n        }\n        // use custom serialize function if available\n        if (curr[key].deserialize) {\n          deserialize = curr[key].deserialize;\n        }\n      }\n      // Ensure that encrypt and decrypt functions are both presents\n      if (curr[key].encrypt && curr[key].decrypt) {\n        if (typeof curr[key].encrypt === 'function' && typeof curr[key].decrypt === 'function') {\n          decrypt = curr[key].decrypt;\n        } else {\n          console.error(\"Either encrypt or decrypt is not a function on '\" + curr[key] + \"' key object.\");\n        }\n      } else if (curr[key].encrypt || curr[key].decrypt) {\n        // Let know that one of the encryption functions is not provided\n        console.error(\"Either encrypt or decrypt function is not present on '\" + curr[key] + \"' key object.\");\n      }\n    }\n    var stateSlice = storage.getItem(storageKeySerializer(key));\n    if (stateSlice) {\n      // Use provided decrypt function\n      if (decrypt) {\n        stateSlice = decrypt(stateSlice);\n      }\n      var isObjectRegex = new RegExp('{|\\\\[');\n      var raw = stateSlice;\n      if (stateSlice === 'null' || isObjectRegex.test(stateSlice.charAt(0))) {\n        raw = JSON.parse(stateSlice, reviver);\n      }\n      return Object.assign({}, acc, (_a = {}, _a[key] = deserialize ? deserialize(raw) : raw, _a));\n    }\n    return acc;\n    var _a;\n  }, {});\n};\nexports.syncStateUpdate = function (state, keys, storage, storageKeySerializer, removeOnUndefined, syncCondition) {\n  if (syncCondition) {\n    try {\n      if (syncCondition(state) !== true) {\n        return;\n      }\n    } catch (e) {\n      // Treat TypeError as do not sync\n      if (e instanceof TypeError) {\n        return;\n      }\n      throw e;\n    }\n  }\n  keys.forEach(function (key) {\n    var stateSlice = state[key];\n    var replacer = undefined;\n    var space = undefined;\n    var encrypt = undefined;\n    if (typeof key === 'object') {\n      var name_1 = Object.keys(key)[0];\n      stateSlice = state[name_1];\n      if (typeof stateSlice !== 'undefined' && key[name_1]) {\n        // use serialize function if specified.\n        if (key[name_1].serialize) {\n          stateSlice = key[name_1].serialize(stateSlice);\n        } else {\n          // if serialize function is not specified filter on fields if an array has been provided.\n          var filter = undefined;\n          if (key[name_1].reduce) {\n            filter = key[name_1];\n          } else if (key[name_1].filter) {\n            filter = key[name_1].filter;\n          }\n          if (filter) {\n            stateSlice = filter.reduce(function (memo, attr) {\n              memo[attr] = stateSlice[attr];\n              return memo;\n            }, {});\n          }\n          // Check if encrypt and decrypt are present, also checked at this#rehydrateApplicationState()\n          if (key[name_1].encrypt && key[name_1].decrypt) {\n            if (typeof key[name_1].encrypt === 'function') {\n              encrypt = key[name_1].encrypt;\n            }\n          } else if (key[name_1].encrypt || key[name_1].decrypt) {\n            // If one of those is not present, then let know that one is missing\n            console.error(\"Either encrypt or decrypt function is not present on '\" + key[name_1] + \"' key object.\");\n          }\n        }\n        /*\r\n                    Replacer and space arguments to pass to JSON.stringify.\r\n                    If these fields don't exist, undefined will be passed.\r\n                */\n        replacer = key[name_1].replacer;\n        space = key[name_1].space;\n      }\n      key = name_1;\n    }\n    if (typeof stateSlice !== 'undefined') {\n      try {\n        if (encrypt) {\n          // ensure that a string message is passed\n          stateSlice = encrypt(typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));\n        }\n        storage.setItem(storageKeySerializer(key), typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));\n      } catch (e) {\n        console.warn('Unable to save state to localStorage:', e);\n      }\n    } else if (typeof stateSlice === 'undefined' && removeOnUndefined) {\n      try {\n        storage.removeItem(storageKeySerializer(key));\n      } catch (e) {\n        console.warn(\"Exception on removing/cleaning undefined '\" + key + \"' state\", e);\n      }\n    }\n  });\n};\nexports.localStorageSync = function (config) {\n  return function (reducer) {\n    if (config.storage === undefined) {\n      config.storage = localStorage || window.localStorage;\n    }\n    if (config.storageKeySerializer === undefined) {\n      config.storageKeySerializer = function (key) {\n        return key;\n      };\n    }\n    if (config.restoreDates === undefined) {\n      config.restoreDates = true;\n    }\n    var stateKeys = validateStateKeys(config.keys);\n    var rehydratedState = config.rehydrate ? exports.rehydrateApplicationState(stateKeys, config.storage, config.storageKeySerializer, config.restoreDates) : undefined;\n    return function (state, action) {\n      if (state === void 0) {\n        state = rehydratedState;\n      }\n      /*\r\n           Handle case where state is rehydrated AND initial state is supplied.\r\n           Any additional state supplied will override rehydrated state for the given key.\r\n           */\n      if ((action.type === INIT_ACTION || action.type === UPDATE_ACTION) && rehydratedState) {\n        state = Object.assign({}, state, rehydratedState);\n      }\n      var nextState = reducer(state, action);\n      exports.syncStateUpdate(nextState, stateKeys, config.storage, config.storageKeySerializer, config.removeOnUndefined, config.syncCondition);\n      return nextState;\n    };\n  };\n};\n/*\r\n    @deprecated: Use localStorageSync(LocalStorageConfig)\r\n\r\n    Wraps localStorageSync functionality acepting the removeOnUndefined boolean parameter in order\r\n    to clean/remove the state from the browser on situations like state reset or logout.\r\n    Defines localStorage as default storage.\r\n*/\nexports.localStorageSyncAndClean = function (keys, rehydrate, removeOnUndefined) {\n  if (rehydrate === void 0) {\n    rehydrate = false;\n  }\n  if (removeOnUndefined === void 0) {\n    removeOnUndefined = false;\n  }\n  return function (reducer) {\n    var config = {\n      keys: keys,\n      rehydrate: rehydrate,\n      storage: localStorage,\n      removeOnUndefined: removeOnUndefined\n    };\n    return _this.localStorageSync(config);\n  };\n};\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}